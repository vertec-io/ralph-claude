# Ralph Progress Log
Effort: ralph-infrastructure-unification
Type: Feature
Started: 2026-01-23

## Codebase Patterns
- Python package is `ralph-uv` with `src/ralph_uv/` layout and hatchling build backend
- CLI command is `ralph-uv` (not `ralph`) to coexist with ralph.sh
- pyproject.toml contains all tool config (mypy, ruff) - no separate config files
- CLI uses argparse with subparsers for subcommands
- uv is the package manager; `uv run ralph-uv` for dev, never install globally
- mypy runs in strict mode: `uv run mypy src/ralph_uv/`
- py.typed marker file present for PEP 561 compliance
- .gitignore uses /prd.json and /progress.txt (root-only) so task dir files are tracked
- Loop module (src/ralph_uv/loop.py) is the core: LoopConfig, LoopRunner
- Agent module (src/ralph_uv/agents.py): Agent ABC, ClaudeAgent, OpencodeAgent, FailureTracker, create_agent(), resolve_agent()
- Branch module (src/ralph_uv/branch.py): BranchConfig, setup_branch(), handle_completion(), create_branch_config()
- Session module (src/ralph_uv/session.py): SessionDB (SQLite), SessionInfo, tmux ops, signal files, start/stop/checkpoint
- Agent resolution priority: CLI --agent > story.agent > prd.agent > "claude" default
- LoopConfig.agent_override holds the CLI override; resolve_agent() does the priority logic
- Agents invoke CLIs directly (claude, opencode) - no shell script intermediaries
- Use `signal._HANDLER` type (not `signal.Handlers`) for signal handler storage
- Git operations use subprocess.run with BranchError exception for error handling
- PR creation/merge uses `gh` CLI with graceful fallback if not installed
- Session data at ~/.local/share/ralph/ (sessions.db, signals/, sockets/)
- Tmux sessions prefixed with "ralph-" to avoid collisions with user sessions
- Signal files are one-shot: consumed on read to prevent duplicate processing
- Prompt module (src/ralph_uv/prompt.py): PromptContext, build_prompt(), load_prompt_template(), substitute_variables(), find_agents_md(), preprocess_agent_sections()
- Template search order: task dir > ~/.config/ralph/ > project root > ~/.local/share/ralph/ > fallback
- Variable substitution uses {VAR_NAME} pattern (uppercase letters, digits, underscores only)
- Agent-specific sections use <!-- agent:X --> / <!-- /agent:X --> HTML comment markers
- RPC module (src/ralph_uv/rpc.py): RpcServer, SessionState, EventSubscriber, get_socket_path(), cleanup_socket()
- RPC server runs asyncio event loop in a daemon thread (threading.Thread + asyncio.new_event_loop)
- JSON-RPC 2.0 over NDJSON on Unix sockets at ~/.local/share/ralph/sockets/<task>.sock
- RPC methods: get_status, stop, checkpoint, inject_prompt, set_interactive_mode, subscribe, unsubscribe
- Events broadcast via _broadcast_event(): "output" and "state_change" types
- Use asyncio.run_coroutine_threadsafe() for cross-thread async coordination
- Socket permissions set to 0o600 for security
- Opencode plugin at plugins/opencode-ralph-hook/ (TypeScript, built with tsc to dist/)
- OpencodeAgent deploys plugin to .opencode/plugins/ralph-hook/ in working dir before spawn
- Signal file mechanism: RALPH_SIGNAL_FILE env var -> temp dir -> plugin writes idle.signal JSON
- OpencodeAgent.run() overrides base to add interactive_mode-aware signal detection
- Plugin is no-op when RALPH_SIGNAL_FILE not set (safe for global install)
- deploy_plugin_globally() and is_plugin_installed_globally() utilities in agents.py
---

## 2026-01-23 - US-001: Python Package Scaffold
- Created src/ralph/__init__.py with __version__
- Created src/ralph/cli.py with argparse-based CLI (run, status, stop, checkpoint, attach subcommands)
- Created src/ralph/py.typed marker
- Created pyproject.toml with hatchling backend, Python >=3.12, [project.scripts] entry
- Added mypy as dev dependency, configured strict mode
- Updated .gitignore for Python artifacts and fixed prd.json/progress.txt patterns
- Files changed: pyproject.toml, src/ralph/__init__.py, src/ralph/cli.py, src/ralph/py.typed, .gitignore, uv.lock
- **Learnings for future iterations:**
  - uv creates a .venv directory automatically on first `uv run` - already in .gitignore
  - hatchling needs `packages = ["src/ralph"]` in [tool.hatch.build.targets.wheel] for src layout
  - Python 3.12+ enables match/case statements (used in CLI)
  - The project had Python 3.14 installed via mise - pyproject.toml requires >=3.12 so it's compatible
---

## 2026-01-23 - US-002: Core Loop Logic in Python
- Fixed mypy type errors in loop.py (signal handler types, Any returns)
- Added _cmd_run() function to cli.py to wire up LoopRunner
- Core loop module at src/ralph/loop.py already existed with:
  - LoopConfig dataclass (task_dir, max_iterations=50, agent, rotate_threshold=300, failover_threshold=3)
  - LoopRunner class with _run_loop(), _run_agent(), _rotate_progress_if_needed()
  - FailureTracker class for per-agent consecutive failure tracking + failover
  - IterationResult dataclass for structured agent output
  - SIGINT/SIGTERM handling with checkpoint writing
  - <promise>COMPLETE</promise> detection in agent output
  - Progress.txt rotation when exceeding threshold
- Files changed: src/ralph/cli.py, src/ralph/loop.py, tasks/ralph-infrastructure-unification/prd.json
- **Learnings for future iterations:**
  - signal.getsignal() returns `signal._HANDLER` type, not `signal.Handlers` - use `signal._HANDLER` for type annotations
  - For `dict[str, Any]` returns from json.loads(), use explicit type annotation on the receiving variable to avoid no-any-return
  - Use `str()` wrapper on `.get()` results to satisfy strict mypy return type checks
  - The agents/ directory contains bash wrapper scripts (claude.sh, opencode.sh) that accept prompts via stdin
  - ruff is configured in pyproject.toml but not installed as dev dependency (only mypy is)
---

## 2026-01-23 - US-001: Python Package Scaffold (rename to ralph-uv)
- Renamed src/ralph/ to src/ralph_uv/ to match PRD requirements
- Updated all imports from `ralph` to `ralph_uv`
- Updated pyproject.toml: project name to ralph-uv, scripts entry to ralph-uv, build packages to src/ralph_uv, mypy packages to ralph_uv
- Updated CLI prog name to ralph-uv, version string to ralph-uv
- Regenerated uv.lock for the renamed package
- Verified: `uv run ralph-uv --version` prints "ralph-uv 0.1.0"
- Verified: `uv run ralph-uv --help` shows all subcommands
- Verified: `uv run mypy src/ralph_uv/` passes with no errors
- Files changed: src/ralph_uv/ (renamed from src/ralph/), pyproject.toml, uv.lock, prd.json, progress.txt
- **Learnings for future iterations:**
  - Package import name is `ralph_uv` (underscore), CLI command is `ralph-uv` (hyphen)
  - After renaming a package, must regenerate uv.lock with `uv lock`
   - hatchling build target must match the actual directory: `packages = ["src/ralph_uv"]`
---

## 2026-01-23 - US-003: Agent Abstraction Layer
- Created src/ralph_uv/agents.py with Agent ABC, ClaudeAgent, OpencodeAgent, FailureTracker, create_agent(), resolve_agent()
- Agent base class has abstract start(), is_done(), get_output() methods + concrete run() convenience method
- ClaudeAgent: invokes `claude --print --output-format stream-json`, parses stream-json for result
- OpencodeAgent: invokes `opencode run`, placeholder for full implementation in US-008
- resolve_agent() implements priority: CLI --agent > story.agent > prd.agent > "claude" default
- FailureTracker moved from loop.py to agents.py (same logic, now co-located with agents)
- Refactored loop.py: removed _run_agent shell-script approach, _find_agents_dir, _extract_output, _detect_failure, _extract_error
- Added LoopConfig.agent_override field for CLI pass-through
- Updated cli.py to pass agent_override instead of resolved agent name
- mypy passes clean (4 source files, no errors)
- Files changed: src/ralph_uv/agents.py (new), src/ralph_uv/loop.py, src/ralph_uv/cli.py, prd.json
- **Learnings for future iterations:**
  - Agents invoke CLIs directly via subprocess.Popen - no need for bash wrapper scripts in agents/
  - Agent.run() handles the full lifecycle: start -> write prompt to stdin -> wait -> get_output
  - process.communicate() handles reading remaining stdout/stderr after stdin.close()
  - ClaudeAgent uses `--print` mode which reads prompt from stdin when piped
  - OpenCode uses `opencode run` which also reads prompt from stdin
   - The `data: dict[str, Any] = json.loads(line)` pattern satisfies mypy strict for json parsing
---

## 2026-01-23 - US-004: Branch Management
- Created src/ralph_uv/branch.py with BranchConfig, setup_branch(), handle_completion(), validate_branch_state()
- Added base_branch field to LoopConfig dataclass
- Wired --base-branch CLI arg through to LoopConfig
- Integrated _setup_branch() at start of _run_loop() and _handle_branch_completion() at both completion paths
- Branch setup: validates clean working tree, checks out or creates task branch from base
- Completion handling: pushes branch, creates PR (and optionally merges) via gh CLI
- All git operations via subprocess with proper error handling (BranchError exception class)
- Files changed: src/ralph_uv/branch.py (new), src/ralph_uv/loop.py, src/ralph_uv/cli.py, prd.json, progress.txt
- **Learnings for future iterations:**
  - Branch module uses _run_git() helper that wraps subprocess.run with check=True and BranchError conversion
  - PR creation/merge uses gh CLI - gracefully handles missing gh or existing PRs
  - BranchConfig is created from prd.json data via create_branch_config() factory
  - setup_branch() is idempotent: if already on task branch, it's a no-op
  - handle_completion() is safe: no mergeTarget means no action taken
---

## 2026-01-23 - US-005: Session Management (tmux + SQLite)
- Created src/ralph_uv/session.py with SessionDB, SessionInfo, tmux operations, signal file ops
- SessionDB: SQLite at ~/.local/share/ralph/sessions.db with register/update/list/remove
- Tmux: create_session (detached, gets pane PID), kill_session, session_exists, list_sessions
- Signal files: ~/.local/share/ralph/signals/<task>.signal for stop/checkpoint communication
- start_session(): creates tmux session running ralph-uv, registers in DB
- stop_session(): writes "stop" signal + sends SIGINT to process
- checkpoint_session(): writes "checkpoint" signal (loop pauses after current iteration)
- cleanup_session(): kills tmux, updates DB status, clears signals
- get_status(): formats session list as table or JSON (--json flag)
- Integrated into LoopRunner: register at start, update progress each iteration, check signals, set final status
- Added _checkpoint_requested flag alongside _shutdown_requested for distinguishing stop vs checkpoint
- CLI commands wired: status (--json), stop <task>, checkpoint <task>
- Files changed: src/ralph_uv/session.py (new), src/ralph_uv/loop.py, src/ralph_uv/cli.py, prd.json
- **Learnings for future iterations:**
  - SessionDB validates running sessions against actual tmux state (list_running stale detection)
  - Signal files are consumed on read (one-shot) to prevent duplicate processing
  - tmux session names prefixed with "ralph-" to avoid collisions
  - task_name_from_dir() uses the directory name (e.g., "my-feature" from tasks/my-feature/)
  - LoopRunner checks signals at start of each iteration AND after agent run returns
  - _shell_quote() handles command args for tmux new-session; uses single-quoting strategy
  - sqlite3.Row factory enables dict-like access to query results
---

## 2026-01-23 - US-006: Prompt Preprocessing
- Created src/ralph_uv/prompt.py with PromptContext, build_prompt(), load_prompt_template(), substitute_variables(), find_agents_md(), preprocess_agent_sections()
- PromptContext dataclass holds task_dir, prd_file, progress_file, branch_name, agent, extra_vars
- load_prompt_template() searches: task dir > ~/.config/ralph/ > project root > ~/.local/share/ralph/ > fallback
- substitute_variables() replaces {VAR_NAME} patterns (uppercase+underscores) with context values
- find_agents_md() collects AGENTS.md from project root and task directory
- preprocess_agent_sections() filters <!-- agent:X --> conditional blocks (keeps current agent, removes others)
- build_prompt() is the main entry: load template -> filter agents -> substitute vars -> inject AGENTS.md -> add header
- Refactored loop.py: removed _load_prompt_template(), simplified _build_prompt() to use PromptContext + build_prompt()
- _run_agent() now passes agent_name to _build_prompt() for agent-specific section filtering
- Files changed: src/ralph_uv/prompt.py (new), src/ralph_uv/loop.py, prd.json
- **Learnings for future iterations:**
  - The {VARIABLE} regex only matches uppercase+underscores to avoid matching JSON `{"key": "value"}` patterns
  - preprocess_agent_sections() uses re.DOTALL flag to handle multi-line agent blocks
  - AGENTS.md is injected between the header and the prompt template content
  - PromptContext.to_vars() returns a flat dict used by substitute_variables()
---

## 2026-01-23 - US-007: TUI Communication Protocol (JSON-RPC over Unix Socket)
- Created src/ralph_uv/rpc.py with RpcServer, SessionState, EventSubscriber, RpcError classes
- JSON-RPC 2.0 server over Unix domain sockets at ~/.local/share/ralph/sockets/<task>.sock
- SessionState dataclass holds mutable state: iteration, story, agent, interactive_mode, recent_output
- RPC methods: get_status, stop, checkpoint, inject_prompt, set_interactive_mode, subscribe, unsubscribe
- Event subscription system: clients subscribe to "output", "state_change", or "*" events
- Events broadcast as JSON-RPC notifications (no id) to all subscribed clients
- RpcServer runs asyncio event loop in a separate daemon thread (non-blocking to main loop)
- Integrated into LoopRunner: _start_rpc_server() at run start, _stop_rpc_server() in finally block
- _update_rpc_state() emits state_change events on iteration/story/agent changes
- _rpc_append_output() captures last 50 lines of agent output per iteration for TUI
- inject_prompt support: injected text prepended to next agent prompt, then cleared
- RPC stop/checkpoint commands trigger same shutdown flags as signal-file approach
- Created docs/protocol.md with full protocol documentation, examples in Python and Rust
- Protocol is additive: ralph-tui can still read prd.json and progress.txt directly
- Files changed: src/ralph_uv/rpc.py (new), src/ralph_uv/loop.py, docs/protocol.md (new), prd.json
- **Learnings for future iterations:**
  - asyncio.run_coroutine_threadsafe() bridges sync main loop to async RPC server
  - asyncio.new_event_loop() + threading.Thread for running asyncio alongside synchronous code
  - NDJSON (newline-delimited JSON) is the simplest framing protocol for streaming
  - deque(maxlen=N) is ideal for bounded output buffers
  - Socket cleanup is critical: always unlink stale .sock files before bind
  - os.chmod(path, 0o600) restricts socket access to owner only
   - loop.call_soon_threadsafe() is needed for cross-thread event loop scheduling
---

## 2026-01-23 - US-008: Opencode Stop-Hook Plugin
- Created plugins/opencode-ralph-hook/ TypeScript package:
  - package.json with typescript + @types/node devDeps
  - tsconfig.json targeting ES2022/CommonJS
  - src/index.ts: plugin that hooks session.idle, writes signal file
- Plugin reads RALPH_SIGNAL_FILE env var to find signal path
- Signal format: { event: "idle", timestamp: ISO, session_id: id }
- Atomic write via temp file + rename to prevent partial reads
- Rewrote OpencodeAgent in agents.py:
  - _setup_signal_file(): creates temp dir for signal
  - _deploy_plugin(): copies built dist/ to .opencode/plugins/ralph-hook/
  - _build_env(): sets RALPH_SIGNAL_FILE + RALPH_SESSION_ID env vars
  - _check_signal_file(): polls for signal file existence
  - _discard_signal_file(): consumes stale signals during interactive mode
  - _cleanup_signal(): removes temp dir after run
  - run() override: interactive_mode-aware completion loop
- Added deploy_plugin_globally() and is_plugin_installed_globally() utilities
- Updated .gitignore: node_modules/ and plugin dist/ excluded
- Documented plugin mechanism in README.md
- Both mypy (Python) and tsc (TypeScript) pass cleanly
- Files changed: plugins/opencode-ralph-hook/ (new), src/ralph_uv/agents.py, .gitignore, README.md, prd.json
- **Learnings for future iterations:**
  - OpenCode (now archived, renamed to Crush) is a Go app - its plugin system is convention-based, not a formal API
  - TypeScript plugin uses CommonJS module.exports for require() compatibility
  - Atomic file writes (write tmp + rename) prevent partial-read race conditions
  - tempfile.mkdtemp() creates unique dirs per-run, shutil.rmtree() cleans up
  - AgentConfig.interactive_mode flag lets OpencodeAgent suppress completion
  - Plugin is safe for global install: no-op without RALPH_SIGNAL_FILE env var
  - The _PLUGIN_DIR class variable uses Path(__file__).parent.parent.parent to find bundled plugin
---
