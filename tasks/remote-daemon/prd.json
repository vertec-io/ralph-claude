{
  "schemaVersion": "2.0",
  "project": "ralph-claude",
  "taskDir": "tasks/remote-daemon",
  "branchName": "ralph/remote-loop-execution",
  "mergeTarget": "ralph/remote-loop-execution",
  "autoMerge": false,
  "type": "feature",
  "description": "Remote Daemon (ralphd) - Long-running daemon that accepts loop requests over OpenZiti and executes them via opencode serve HTTP API",
  "userStories": [
    {
      "id": "US-001",
      "title": "Daemon CLI entrypoint and configuration loading",
      "description": "As a developer, I need a ralphd entrypoint that loads configuration and starts the daemon process.",
      "acceptanceCriteria": [
        {
          "description": "New CLI entrypoint 'ralphd' registered in pyproject.toml (separate from ralph-uv)",
          "passes": true
        },
        {
          "description": "Loads config from ~/.config/ralph/daemon.toml (workspace_dir, max_concurrent_loops, ziti identity path)",
          "passes": true
        },
        {
          "description": "Loads environment variables from ~/.config/ralph/env (API keys, PATH extensions)",
          "passes": true
        },
        {
          "description": "Accepts --identity flag to override Ziti identity path",
          "passes": true
        },
        {
          "description": "Accepts --workspace-dir flag to override workspace directory",
          "passes": true
        },
        {
          "description": "Logs to ~/.local/state/ralph-uv/daemon.log with rotation",
          "passes": true
        },
        {
          "description": "Graceful shutdown on SIGTERM/SIGINT (cleanup active loops)",
          "passes": true
        },
        {
          "description": "Typecheck passes",
          "passes": true
        }
      ],
      "priority": 1,
      "passes": true,
      "notes": ""
    },
    {
      "id": "US-002",
      "title": "OpenZiti SDK integration and control service binding",
      "description": "As a developer, I need the daemon to load a Ziti identity and bind a control service for receiving requests.",
      "acceptanceCriteria": [
        {
          "description": "Load Ziti identity JSON file using openziti Python SDK",
          "passes": true
        },
        {
          "description": "Bind to Ziti service ralph-control-{hostname} for incoming RPC connections",
          "passes": true
        },
        {
          "description": "Accept multiple concurrent client connections on the control service",
          "passes": true
        },
        {
          "description": "Handle connection lifecycle (accept, read, respond, close)",
          "passes": true
        },
        {
          "description": "Log Ziti enrollment/binding status on startup",
          "passes": true
        },
        {
          "description": "Graceful Ziti teardown on shutdown (unbind services, close context)",
          "passes": true
        },
        {
          "description": "Typecheck passes",
          "passes": true
        }
      ],
      "priority": 2,
      "passes": true,
      "notes": "Implemented in ziti.py with ZitiService and ZitiControlService classes. Integrated into daemon.py with DaemonConnectionHandler. Added openziti>=1.0.0 dependency."
    },
    {
      "id": "US-003",
      "title": "Daemon control RPC protocol",
      "description": "As a developer, I need the daemon to handle JSON-RPC 2.0 requests for managing loops.",
      "acceptanceCriteria": [
        {
          "description": "start_loop method: accepts origin_url, branch, task_dir, max_iterations, agent params",
          "passes": true
        },
        {
          "description": "stop_loop method: accepts loop_id, sends abort to the running loop",
          "passes": true
        },
        {
          "description": "list_loops method: returns all active loops with status, iteration, agent, task info",
          "passes": true
        },
        {
          "description": "get_health method: returns daemon uptime, active loop count, system resources",
          "passes": true
        },
        {
          "description": "get_agents method: returns available agent CLIs with versions",
          "passes": true
        },
        {
          "description": "JSON-RPC 2.0 error responses for invalid params, agent not found, max loops exceeded",
          "passes": true
        },
        {
          "description": "NDJSON framing on the Ziti stream (same as existing RPC protocol)",
          "passes": true
        },
        {
          "description": "Typecheck passes",
          "passes": true
        }
      ],
      "priority": 3,
      "passes": true,
      "notes": "Implemented in daemon_rpc.py with DaemonRpcHandler. Integrated into daemon.py DaemonConnectionHandler. All RPC methods implemented with proper error handling and NDJSON framing."
    },
    {
      "id": "US-004",
      "title": "Git workspace management",
      "description": "As a developer, I need the daemon to manage git workspaces for incoming loop requests.",
      "acceptanceCriteria": [
        {
          "description": "Resolve project name from origin URL (strip .git suffix, take last path component)",
          "passes": true
        },
        {
          "description": "Create ~/ralph-workspaces/{project}/bare.git via git clone --bare on first use",
          "passes": true
        },
        {
          "description": "Validate origin URL matches existing bare repo (error if mismatch)",
          "passes": true
        },
        {
          "description": "git fetch origin {branch} into bare repo on each start_loop request",
          "passes": true
        },
        {
          "description": "Create isolated worktree: git worktree add checkouts/{task}-{uuid} {branch}",
          "passes": true
        },
        {
          "description": "git worktree prune on daemon startup to clean stale worktrees",
          "passes": true
        },
        {
          "description": "Return checkout path in start_loop response",
          "passes": true
        },
        {
          "description": "Handle errors: origin unreachable, branch not found, disk full",
          "passes": true
        },
        {
          "description": "Typecheck passes",
          "passes": true
        }
      ],
      "priority": 4,
      "passes": true,
      "notes": "Implemented in workspace.py with WorkspaceManager class. Integrated into daemon.py and daemon_rpc.py. start_loop now sets up git workspace and returns worktree_path."
    },
    {
      "id": "US-005",
      "title": "Agent CLI detection and auto-install",
      "description": "As a developer, I need the daemon to verify agent availability and attempt auto-install if missing.",
      "acceptanceCriteria": [
        {
          "description": "Check 'which opencode' before starting a loop",
          "passes": true
        },
        {
          "description": "If missing: attempt curl -fsSL https://opencode.ai/install | bash",
          "passes": true
        },
        {
          "description": "Verify installation succeeded with which opencode after install",
          "passes": true
        },
        {
          "description": "Return structured error if auto-install fails (with install instructions)",
          "passes": true
        },
        {
          "description": "Cache agent availability (don't re-check on every loop start)",
          "passes": true
        },
        {
          "description": "get_agents RPC returns installed agents with version numbers",
          "passes": true
        },
        {
          "description": "Typecheck passes",
          "passes": true
        }
      ],
      "priority": 5,
      "passes": true,
      "notes": "Implemented in agent_manager.py with AgentManager class. Auto-install via curl for opencode and npm for claude. 5-minute cache TTL. Structured errors with install instructions."
    },
    {
      "id": "US-006",
      "title": "OpenCode serve lifecycle management",
      "description": "As a developer, I need the daemon to start opencode serve for each loop and manage its lifecycle.",
      "acceptanceCriteria": [
        {
          "description": "Start 'opencode serve --port {auto} --hostname 127.0.0.1' per loop",
          "passes": true
        },
        {
          "description": "Port allocation: start at 4096, increment if in use",
          "passes": true
        },
        {
          "description": "Wait for health check: GET /global/health returns 200 before proceeding",
          "passes": true
        },
        {
          "description": "Track opencode server PID and port per loop in daemon's internal registry",
          "passes": true
        },
        {
          "description": "Set OPENCODE_PERMISSION env to allow all permissions (yolo mode)",
          "passes": true
        },
        {
          "description": "Set API key environment variables from daemon's loaded env",
          "passes": true
        },
        {
          "description": "Set working directory to the worktree checkout path",
          "passes": true
        },
        {
          "description": "On stop_loop: send POST /session/:id/abort, then SIGTERM, then SIGKILL after timeout",
          "passes": true
        },
        {
          "description": "Typecheck passes",
          "passes": true
        }
      ],
      "priority": 6,
      "passes": true,
      "notes": "Implemented in opencode_lifecycle.py with OpenCodeManager and OpenCodeInstance classes. Integrated into daemon.py and daemon_rpc.py. Uses aiohttp for async HTTP. Port range 4096-5096."
    },
    {
      "id": "US-007",
      "title": "Loop iteration driver via opencode HTTP API",
      "description": "As a developer, I need the daemon to drive loop iterations by sending prompts to opencode's HTTP API and detecting completion via SSE.",
      "acceptanceCriteria": [
        {
          "description": "Create a new session via POST /session at start of each iteration",
          "passes": true
        },
        {
          "description": "Build prompt using existing prompt.md template system (reuse prompt.py)",
          "passes": true
        },
        {
          "description": "Send prompt via POST /session/{id}/message (synchronous, waits for response)",
          "passes": true
        },
        {
          "description": "Monitor completion via SSE GET /event stream (wait for session.idle event)",
          "passes": true
        },
        {
          "description": "After each iteration: read prd.json from worktree to check story completion",
          "passes": true
        },
        {
          "description": "If all stories pass: mark loop completed, push to origin, clean up",
          "passes": true
        },
        {
          "description": "If max iterations reached: mark loop exhausted, push to origin",
          "passes": true
        },
        {
          "description": "Handle iteration failures: log error, increment failure counter, retry with backoff",
          "passes": true
        },
        {
          "description": "Include First-Run Setup section in prompt for iteration 1",
          "passes": true
        },
        {
          "description": "Typecheck passes",
          "passes": true
        }
      ],
      "priority": 7,
      "passes": true,
      "notes": "Implemented in daemon_loop.py with LoopDriver class. Integrated into daemon.py and daemon_rpc.py. Uses aiohttp for async HTTP, SSE monitoring for completion detection, exponential backoff for retries."
    },
    {
      "id": "US-008",
      "title": "Per-loop Ziti service registration for client attachment",
      "description": "As a developer, I need each active loop to have its own Ziti service so clients can attach directly.",
      "acceptanceCriteria": [
        {
          "description": "Register Ziti service ralph-loop-{task}-{uuid} when loop starts",
          "passes": true
        },
        {
          "description": "Ziti service proxies to the opencode serve HTTP port (TCP forwarding)",
          "passes": true
        },
        {
          "description": "Clients can opencode attach http://{ziti-intercept}:{port} through the Ziti service",
          "passes": true
        },
        {
          "description": "Deregister Ziti service when loop completes or is stopped",
          "passes": true
        },
        {
          "description": "Multiple clients can connect to the same loop service simultaneously",
          "passes": true
        },
        {
          "description": "Log service registration/deregistration events",
          "passes": true
        },
        {
          "description": "Typecheck passes",
          "passes": true
        }
      ],
      "priority": 8,
      "passes": true,
      "notes": "Implemented ZitiLoopService and ZitiLoopServiceManager in ziti.py. TCP proxy forwards connections to opencode serve port. Integrated into daemon.py (loop_service_manager property), daemon_rpc.py (start_loop/stop_loop), and daemon_loop.py (completion cleanup). Service name format: ralph-loop-{task}-{uuid}."
    },
    {
      "id": "US-009",
      "title": "Git push-back after iterations",
      "description": "As a developer, I need the daemon to push committed work back to origin so progress is visible.",
      "acceptanceCriteria": [
        {
          "description": "After each successful iteration: git push origin {branch} --force-with-lease",
          "passes": true
        },
        {
          "description": "Push is non-fatal: if push fails, log warning and continue",
          "passes": true
        },
        {
          "description": "Configurable push frequency: every N iterations (default: 1)",
          "passes": true
        },
        {
          "description": "Final push on loop completion (ensure all work is pushed)",
          "passes": true
        },
        {
          "description": "Handle push conflicts gracefully (force-with-lease protects against data loss)",
          "passes": true
        },
        {
          "description": "Typecheck passes",
          "passes": true
        }
      ],
      "priority": 9,
      "passes": true,
      "notes": "Already implemented in US-007. _push_to_origin method in daemon_loop.py:632-680 handles git push with --force-with-lease, non-fatal errors, configurable push_frequency in LoopState/LoopInfo, and final push on completion/exhaustion."
    },
    {
      "id": "US-010",
      "title": "Loop completion events and client notification",
      "description": "As a developer, I need the daemon to notify connected clients when loops complete.",
      "acceptanceCriteria": [
        {
          "description": "On loop completion: emit loop_completed event on the control service",
          "passes": true
        },
        {
          "description": "Event payload includes: loop_id, task_name, status, iterations_used, final_story, branch",
          "passes": true
        },
        {
          "description": "On loop failure: emit loop_failed event with error details",
          "passes": true
        },
        {
          "description": "Clients subscribed to control service receive events in real-time",
          "passes": true
        },
        {
          "description": "If no client connected: events are logged but not queued",
          "passes": true
        },
        {
          "description": "Typecheck passes",
          "passes": true
        }
      ],
      "priority": 10,
      "passes": true,
      "notes": "Implemented EventBroadcaster in daemon.py for real-time event broadcasting. LoopEvent dataclass carries loop_id, task_name, status, iterations_used, final_story, branch, and error. Clients subscribe via subscribe_events RPC method. Events are sent as JSON-RPC 2.0 notifications. If no clients are subscribed, events are logged but not queued."
    },
    {
      "id": "US-011",
      "title": "ralphd check validation command",
      "description": "As a developer, I need a self-check command that validates the remote machine is ready.",
      "acceptanceCriteria": [
        {
          "description": "ralphd check runs system validation and reports status",
          "passes": true
        },
        {
          "description": "Checks: Python version, git, Ziti identity (enrolled), workspace dir (writable)",
          "passes": true
        },
        {
          "description": "Checks: API keys set (ANTHROPIC_API_KEY), agent CLIs available",
          "passes": true
        },
        {
          "description": "Checks: Git auth configured (SSH key or credential helper)",
          "passes": true
        },
        {
          "description": "Reports ready/not-ready status with actionable fix instructions",
          "passes": true
        },
        {
          "description": "Exit code 0 if ready, non-zero if issues found",
          "passes": true
        },
        {
          "description": "Typecheck passes",
          "passes": true
        }
      ],
      "priority": 11,
      "passes": true,
      "notes": "Implemented comprehensive validation with CheckResult dataclass. Each check includes actionable fix instructions. Git auth check looks for SSH keys (id_ed25519, id_rsa, etc.) and git credential helper configuration."
    },
    {
      "id": "US-012",
      "title": "Concurrent loop isolation and resource limits",
      "description": "As a developer, I need the daemon to enforce resource limits and isolate concurrent loops.",
      "acceptanceCriteria": [
        {
          "description": "Enforce max_concurrent_loops (configurable, default: 4)",
          "passes": true
        },
        {
          "description": "Return error if max loops exceeded on start_loop request",
          "passes": true
        },
        {
          "description": "Each loop gets: separate worktree, separate opencode serve port, separate Ziti service",
          "passes": true
        },
        {
          "description": "Per-loop timeout (configurable, default: 24h) - terminate loop if exceeded",
          "passes": true
        },
        {
          "description": "Track active loops in daemon's internal registry",
          "passes": true
        },
        {
          "description": "On daemon restart: detect orphaned loop processes, clean up or re-adopt",
          "passes": true
        },
        {
          "description": "Typecheck passes",
          "passes": true
        }
      ],
      "priority": 12,
      "passes": true,
      "notes": "Implemented LoopRegistry for persistence to ~/.local/state/ralph-uv/loop_registry.json. Per-loop timeout_hours field added to LoopInfo, StartLoopParams, LoopState. TIMED_OUT status added to LoopStatus. On daemon restart, orphans are detected and killed (SIGTERM then SIGKILL). Clean shutdown clears the registry. Max concurrent loops and isolation already existed from prior work."
    }
  ],
  "agent": "opencode"
}
