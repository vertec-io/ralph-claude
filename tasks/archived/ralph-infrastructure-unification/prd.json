{
  "schemaVersion": "2.0",
  "project": "Ralph",
  "taskDir": "tasks/ralph-infrastructure-unification",
  "branchName": "ralph/ralph-infrastructure-unification",
  "mergeTarget": null,
  "autoMerge": false,
  "type": "feature",
  "description": "Ralph Infrastructure Unification - Rewrite ralph loop as Python package (ralph-uv), unify TUI communication via JSON-RPC, add interactive agent control, opencode stop-hook plugin, and branch management. ralph.sh remains unchanged.",
  "userStories": [
    {
      "id": "US-001",
      "title": "Python Package Scaffold",
      "description": "As a developer, I want the ralph-uv Python package scaffolded with pyproject.toml and uv tool configuration so that the project can be installed as a CLI tool.",
      "acceptanceCriteria": [
        { "description": "Create pyproject.toml with [project.scripts] entry for ralph-uv CLI", "passes": true },
        { "description": "Python 3.12+ requirement specified", "passes": true },
        { "description": "uv run ralph-uv works for development (do NOT install globally)", "passes": true },
        { "description": "Basic CLI entrypoint prints version and help", "passes": true },
        { "description": "Project uses src/ralph_uv/ layout", "passes": true },
        { "description": "Typecheck passes", "passes": true }
      ],
      "priority": 1,
      "passes": true,
      "notes": "CLI command is ralph-uv (not ralph) to coexist with the existing ralph.sh tool. Use uv run ralph-uv during development. Package layout is src/ralph_uv/."
    },
    {
      "id": "US-002",
      "title": "Core Loop Logic in Python",
      "description": "As a developer, I want the core iteration loop ported from bash to Python so it's maintainable and testable.",
      "acceptanceCriteria": [
        { "description": "Iteration loop spawns agent subprocess, waits for completion, checks results", "passes": true },
        { "description": "Supports max iteration count (configurable, default 50)", "passes": true },
        { "description": "Detects <promise>COMPLETE</promise> in agent output to stop loop", "passes": true },
        { "description": "Progress.txt rotation logic works (threshold configurable, default 300 lines)", "passes": true },
        { "description": "Consecutive failure tracking per agent works", "passes": true },
        { "description": "Graceful shutdown on SIGINT/SIGTERM", "passes": true },
        { "description": "Typecheck passes", "passes": true }
      ],
      "priority": 2,
      "passes": true,
      "notes": "Loop module at src/ralph_uv/loop.py with LoopConfig, LoopRunner, FailureTracker, and IterationResult classes. CLI _cmd_run function wires it up."
    },
    {
      "id": "US-003",
      "title": "Agent Abstraction Layer",
      "description": "As a developer, I want a pluggable agent interface so ralph-uv can run different coding agents (claude code, opencode) with agent-specific completion detection.",
      "acceptanceCriteria": [
        { "description": "Abstract Agent base class with start(), is_done(), get_output() methods", "passes": true },
        { "description": "ClaudeAgent implementation using claude --print --output-format stream-json", "passes": true },
        { "description": "OpencodeAgent implementation (placeholder, full implementation in US-008)", "passes": true },
        { "description": "Agent selection configurable per-task in prd.json and overridable at launch", "passes": true },
        { "description": "Failover logic: switch agents after N consecutive failures (configurable threshold)", "passes": true },
        { "description": "Typecheck passes", "passes": true }
      ],
      "priority": 3,
      "passes": true,
      "notes": "Agent module at src/ralph_uv/agents.py. Agent, ClaudeAgent, OpencodeAgent classes. resolve_agent() handles priority: CLI > story > prd > default. FailureTracker moved from loop.py to agents.py. create_agent() factory function. Loop.py now uses agent abstraction instead of shell scripts."
    },
    {
      "id": "US-004",
      "title": "Branch Management",
      "description": "As a user, I want to specify what branch ralph-uv starts from and what happens at the end of the loop so I have control over git workflow.",
      "acceptanceCriteria": [
        { "description": "ralph-uv run --base-branch <branch> flag to specify starting branch", "passes": true },
        { "description": "If no base-branch specified, use current branch", "passes": true },
        { "description": "ralph-uv creates/checks out the task branch (from prd.json branchName) based off the specified base", "passes": true },
        { "description": "At loop completion: behavior controlled by prd.json mergeTarget and autoMerge fields", "passes": true },
        { "description": "If autoMerge true and mergeTarget set, ralph-uv creates PR and merges automatically", "passes": true },
        { "description": "If autoMerge false and mergeTarget set, ralph-uv creates PR but does not merge", "passes": true },
        { "description": "If no mergeTarget, loop just stops (branch left as-is)", "passes": true },
        { "description": "Branch state validated before starting (clean working tree required)", "passes": true },
        { "description": "Typecheck passes", "passes": true }
      ],
      "priority": 4,
      "passes": true,
      "notes": "Branch module at src/ralph_uv/branch.py. BranchConfig dataclass, setup_branch() for checkout/creation, handle_completion() for PR/merge via gh CLI. Uses subprocess for git operations."
    },
    {
      "id": "US-005",
      "title": "Session Management (tmux + SQLite)",
      "description": "As a user, I want ralph-uv sessions to run in tmux with SQLite tracking so I can manage multiple concurrent loops.",
      "acceptanceCriteria": [
        { "description": "ralph-uv runs agent in a tmux session (one per task)", "passes": true },
        { "description": "SQLite registry at ~/.local/share/ralph/sessions.db tracks running sessions", "passes": true },
        { "description": "ralph-uv status lists all running sessions (with --json flag for machine-readable output)", "passes": true },
        { "description": "ralph-uv stop <task> sends graceful shutdown signal", "passes": true },
        { "description": "ralph-uv checkpoint <task> saves state and pauses", "passes": true },
        { "description": "Session cleanup on normal completion or crash", "passes": true },
        { "description": "Typecheck passes", "passes": true }
      ],
      "priority": 5,
      "passes": true,
      "notes": "Session module at src/ralph_uv/session.py. SessionDB uses SQLite at ~/.local/share/ralph/sessions.db. Tmux sessions prefixed with 'ralph-'. Signal files at ~/.local/share/ralph/signals/<task>.signal for stop/checkpoint. LoopRunner registers session at start, updates progress each iteration, checks signals between iterations, and sets final status on exit."
    },
    {
      "id": "US-006",
      "title": "Prompt Preprocessing",
      "description": "As a developer, I want the prompt.md template system ported to Python so agents receive properly formatted instructions.",
      "acceptanceCriteria": [
        { "description": "Loads prompt.md from task dir, then ~/.config/ralph/prompt.md, then bundled default", "passes": true },
        { "description": "Preprocesses template with task context (prd.json path, progress.txt path, branch info)", "passes": true },
        { "description": "Injects AGENTS.md content if present", "passes": true },
        { "description": "Passes final prompt to agent subprocess", "passes": true },
        { "description": "Supports the existing {VARIABLE} substitution pattern", "passes": true },
        { "description": "Typecheck passes", "passes": true }
      ],
      "priority": 6,
      "passes": true,
      "notes": "Prompt module at src/ralph_uv/prompt.py. PromptContext dataclass holds variables. load_prompt_template() searches 4 locations + fallback. substitute_variables() uses {VAR_NAME} pattern (uppercase+underscores). find_agents_md() loads project-root + task-dir AGENTS.md. preprocess_agent_sections() handles <!-- agent:X --> conditional blocks. build_prompt() is the main entry point."
    },
    {
      "id": "US-007",
      "title": "TUI Communication Protocol (JSON-RPC over Unix Socket)",
      "description": "As a developer, I want a JSON-RPC communication protocol between ralph-uv (Python) and ralph-tui (Rust) so the TUI can observe and control running loops.",
      "acceptanceCriteria": [
        { "description": "ralph-uv exposes a JSON-RPC server on a Unix domain socket per session (~/.local/share/ralph/sockets/<task>.sock)", "passes": true },
        { "description": "State queries: get_status returns current iteration, story, agent, interactive_mode flag, recent output", "passes": true },
        { "description": "Control commands: start, stop, checkpoint, inject_prompt, set_interactive_mode", "passes": true },
        { "description": "Event subscription: TUI can subscribe to real-time output stream and state changes", "passes": true },
        { "description": "Protocol documented in docs/protocol.md", "passes": true },
        { "description": "ralph-tui can still read prd.json and progress.txt directly for supplemental status", "passes": true },
        { "description": "Typecheck passes", "passes": true }
      ],
      "priority": 7,
      "passes": true,
      "notes": "RPC module at src/ralph_uv/rpc.py. SessionState holds mutable state. RpcServer runs asyncio event loop in daemon thread. JSON-RPC 2.0 over NDJSON on Unix socket at ~/.local/share/ralph/sockets/<task>.sock. Methods: get_status, stop, checkpoint, inject_prompt, set_interactive_mode, subscribe, unsubscribe. Events: output, state_change. Protocol documented at docs/protocol.md."
    },
    {
      "id": "US-008",
      "title": "Opencode Stop-Hook Plugin",
      "description": "As a developer, I want an opencode plugin that signals when opencode completes an iteration so ralph-uv can detect completion without polling.",
      "acceptanceCriteria": [
        { "description": "Opencode plugin written in TypeScript per opencode plugin API", "passes": true },
        { "description": "Plugin listens for session.idle event (fires when opencode finishes processing)", "passes": true },
        { "description": "Plugin reads RALPH_SIGNAL_FILE env var to discover where to write the signal", "passes": true },
        { "description": "Signal is a JSON file write: {event: idle, timestamp: iso, session_id: id}", "passes": true },
        { "description": "ralph-uv OpencodeAgent watches the signal file (inotify on Linux) for changes", "passes": true },
        { "description": "Completion only honored when interactive_mode is false", "passes": true },
        { "description": "Plugin loaded via .opencode/plugins/ directory (ralph-uv copies it into task working directory before spawning opencode)", "passes": true },
        { "description": "Fallback: plugin can also be installed globally at ~/.config/opencode/plugins/", "passes": true },
        { "description": "Document plugin mechanism in README", "passes": true },
        { "description": "Typecheck passes", "passes": true }
      ],
      "priority": 8,
      "passes": true,
      "notes": "Plugin at plugins/opencode-ralph-hook/ (TypeScript). OpencodeAgent in agents.py now deploys plugin to .opencode/plugins/ralph-hook/ before spawn, sets RALPH_SIGNAL_FILE env var, and watches signal file for completion. Signal file uses temp dir per-run. Interactive mode discards signal writes. Global install supported at ~/.config/opencode/plugins/ralph-hook/. Fallback to process exit detection if plugin fails."
    },
    {
      "id": "US-012",
      "title": "Interactive Agent Control Mode",
      "description": "As a user, I want to pause the autonomous loop, interact directly with the agent (claude or opencode), and resume autonomous operation without triggering a false iteration completion.",
      "acceptanceCriteria": [
        { "description": "interactive_mode boolean tracked in session state, exposed via JSON-RPC", "passes": true },
        { "description": "Toggling interactive mode ON: sends agent pause key (Esc) through PTY, suppresses completion detection", "passes": true },
        { "description": "While interactive: user keystrokes forwarded directly to agent PTY", "passes": true },
        { "description": "Toggling interactive mode OFF: re-enables completion detection (agent continues from wherever user left it)", "passes": true },
        { "description": "Claude Code: interrupt via Esc, user types input, agent processes and continues", "passes": true },
        { "description": "Opencode: pause via Esc, user types input, agent processes and continues", "passes": true },
        { "description": "Signal file writes during interactive mode are queued/ignored until mode exits", "passes": true },
        { "description": "Output parsing for <promise>COMPLETE</promise> suppressed during interactive mode", "passes": true },
        { "description": "Both ralph-tui and ralph-uv attach support this toggle with the same hotkey (i)", "passes": true },
        { "description": "Visual indicator in UI shows current mode (autonomous vs interactive)", "passes": true },
        { "description": "Typecheck passes", "passes": true }
      ],
      "priority": 9,
      "passes": true,
      "notes": "Interactive module at src/ralph_uv/interactive.py: PtyAgent (PTY-based subprocess), InteractiveController (toggle logic), InteractiveState (state tracking). Attach module at src/ralph_uv/attach.py: RpcClient (JSON-RPC over Unix socket), AttachViewer (terminal UI with hotkeys). Agents now have run_with_pty() method for PTY-based execution. RPC set_interactive_mode triggers on_set_interactive callback to LoopRunner. Hotkey 'i' toggles in both attach and TUI. Mode indicator: 'autonomous' vs 'interactive' in get_status response."
    },
    {
      "id": "US-009",
      "title": "TUI Loop Start Wizard",
      "description": "As a user, I want a full wizard in ralph-tui to start new loops so I don't need to use the CLI separately.",
      "acceptanceCriteria": [
        { "description": "Wizard accessible via hotkey in ralph-tui", "passes": true },
        { "description": "Step 1: Select task directory (list available tasks/ subdirectories)", "passes": true },
        { "description": "Step 2: Configure base branch (default: current branch, option to type another)", "passes": true },
        { "description": "Step 3: Set max iterations (default: 50, editable)", "passes": true },
        { "description": "Step 4: Select agent (claude/opencode, default from prd.json or claude)", "passes": true },
        { "description": "Step 5: Confirm and launch", "passes": true },
        { "description": "Wizard sends start command to ralph-uv via JSON-RPC protocol", "passes": true },
        { "description": "New loop appears in TUI session list immediately", "passes": true },
        { "description": "Typecheck passes", "passes": true }
      ],
      "priority": 10,
      "passes": true,
      "notes": "Wizard accessible via 'w' hotkey in both standalone and attach modes. 5-step wizard: task selection, branch config, iterations, agent, confirm. Launches ralph-uv run as subprocess which registers in SQLite DB and starts its own RPC socket. Session appears in TUI via existing session polling. Wizard module at ralph-tui/src/wizard.rs."
    },
    {
      "id": "US-010",
      "title": "Ralph Attach (Single-Loop View)",
      "description": "As a user, I want ralph-uv attach <task> to show a single-loop view similar to ralph-tui but focused on one session, with full agent interaction support.",
      "acceptanceCriteria": [
        { "description": "ralph-uv attach <task> opens a terminal UI showing one running loop", "passes": true },
        { "description": "Shows: current iteration, story progress, live agent output", "passes": true },
        { "description": "Supports interactive mode toggle (hotkey i) for direct agent interaction", "passes": true },
        { "description": "In interactive mode: PTY input forwarded to agent, completion detection suppressed", "passes": true },
        { "description": "Exiting interactive mode (hotkey i again or Esc) re-enables autonomous monitoring", "passes": true },
        { "description": "Supports stop/checkpoint commands", "passes": true },
        { "description": "Exits cleanly when loop completes or user presses quit key", "passes": true },
        { "description": "Communicates with ralph-uv loop via JSON-RPC protocol", "passes": true },
        { "description": "Part of the Python package (not a separate binary)", "passes": true },
        { "description": "Typecheck passes", "passes": true }
      ],
      "priority": 11,
      "passes": true,
      "notes": "Attach module at src/ralph_uv/attach.py: RpcClient (Unix socket JSON-RPC client), AttachViewer (terminal UI with hotkeys). write_pty RPC method in rpc.py forwards keystrokes to agent PTY via InteractiveController. Esc key or 'i' hotkey exits interactive mode. Connection loss detected via socket disconnect. tty.setcbreak() for hotkey capture, restored in finally block."
    }
  ]
}
